#
# set +o errexit -o noglob is assumed.
#

buildp_init_args() {
	local _last_pkg=""; _status="";
	if [ "${ARG_AS_NEEDED:-0}" -eq 1 ]\
	&& [ -e "${PREFIX}/build.gitref" ]\
	&& [ "$(git rev-parse HEAD)" = "$(cat "${PREFIX}/build.gitref")" ]; then
		_status="Git repository has not changed since last build and --as-needed was specified.";
	fi;
	if [ -n "${ARG_RESTART}" ]; then
		if [ "${ARG_RESTART#\*\*\*}" != "${ARG_RESTART}" ]; then
			ARG_RESTART="${ARG_RESTART#\*\*\*}"; ARG_RESTART_RECURSIVE=3;
		elif [ "${ARG_RESTART#\*\*}" != "${ARG_RESTART}" ]; then
			ARG_RESTART="${ARG_RESTART#\*\*}"; ARG_RESTART_RECURSIVE=2;
		elif [ "${ARG_RESTART#\*}" != "${ARG_RESTART}" ]; then
			ARG_RESTART="${ARG_RESTART#\*}"; ARG_RESTART_RECURSIVE=1;
		fi;
	fi;
	case "${ARG_RESTART}" in
	ALL)	ARG_RESTART_AT=ALL; ARG_RESTART_RECURSIVE=2; ;;
	LAST)	ARG_RESTART_AT=ALL; ARG_RESTART_RECURSIVE=0; ;;
	"")	;;
	*:*)	ARG_RESTART_AT="${ARG_RESTART#*:}"; ARG_RESTART="$(rtl_llift "${ARG_RESTART%%:*}" "," " ")"; ;;
	*)	ARG_RESTART="$(rtl_llift "${ARG_RESTART}" "," " ")"; ARG_RESTART_AT=ALL; ;;
	esac;
	if [ "${ARG_RESTART}" = "LAST" ]; then
		if [ -n "${DEFAULT_BUILD_LAST_FAILED_PKG_FNAME}" ]\
		&& [ -e "${DEFAULT_BUILD_LAST_FAILED_PKG_FNAME}" ]; then
			_last_pkg="$(cat "${DEFAULT_BUILD_LAST_FAILED_PKG_FNAME}")";
			rtl_fileop rm "${DEFAULT_BUILD_LAST_FAILED_PKG_FNAME}";
			rtl_state_clear "${BUILD_WORKDIR}" "${_last_pkg}";
			ARG_RESTART="${_last_pkg}";
		fi;
	fi;
	rtl_log_set_vnfo_lvl "${ARG_VERBOSE:-0}";
	case "${ARG_FETCH_FORCE}" in
	ipv4)	DEFAULT_GIT_ARGS="$(rtl_lconcat "-4" "${DEFAULT_GIT_ARGS}")";
		DEFAULT_WGET_ARGS="$(rtl_lconcat "-4" "${DEFAULT_GIT_ARGS}")"; ;;
	ipv6)	DEFAULT_GIT_ARGS="$(rtl_lconcat "-6" "${DEFAULT_GIT_ARGS}")";
		DEFAULT_WGET_ARGS="$(rtl_lconcat "-6" "${DEFAULT_GIT_ARGS}")"; ;;
	esac;
	return 0;
};

buildp_init_defaults() {
	local _rc=0; _status="";

	# Command-line arguments
	: ${ARCH:="nt64"}; : ${BUILD:="debug"};
	ARG_AS_NEEDED=0; ARG_CLEAN_BUILDS=""; ARG_DEBUG_MINIPIX=0; ARG_DUMP_IN="";
	ARG_DUMP_ON_ABORT=0; ARG_DIST=""; ARG_FETCH_FORCE=0; ARG_PARALLEL=1; ARG_RELAXED=0;
	ARG_RESTART=""; ARG_VERBOSE=0;

	# Build parameters & state
	BUILD_HNAME=""; BUILD_IS_PARENT=1; BUILD_GROUPS=""; BUILD_GROUPS_INHIBIT_DEPS=0;
	BUILD_TARGET=""; BUILD_USER=""; MIDIPIX_BUILD_PWD="";

	# Global defaults
	DEFAULT_BUILD_CPUS=1;
	DEFAULT_BUILD_LAST_FAILED_PKG_FNAME=""
	DEFAULT_BUILD_LOG_FNAME="";
	DEFAULT_BUILD_STATUS_IN_PROGRESS_FNAME="";
	DEFAULT_BUILD_STEPS="";
	DEFAULT_BUILD_VARS="";
	DEFAULT_CLEAR_PREFIX_PATHS="";
	DEFAULT_GIT_ARGS="";
	DEFAULT_GITROOT_HEAD="";
	DEFAULT_LOG_ENV_VARS="";
	DEFAULT_TARGET="";
	DEFAULT_WGET_ARGS="";

	return "${_rc}";
};

buildp_init_env() {
	local _fname="" _rc=0; _status="";
	if ! umask 022; then
		printf "Error: failed to setup environment.\n"; exit 1;
	else	for _fname in $(find subr -name *.subr); do
			if ! . "${_fname}"; then
				printf "Error: failed to source \`%s'.\n" "${_fname}"; exit 1;
			fi;
		done; fi;
	return "${_rc}";
};

buildp_init_files() {
	local _log_last_fname="" _log_last_ts="" _rc=0; _status=""
	if ! rtl_fileop mkdir "${BUILD_DLCACHEDIR}" "${BUILD_WORKDIR}"\
	|| rtl_lmatch "${ARG_DIST}" "rpm" ","\
	&& ! rtl_fileop mkdir "${PREFIX_RPM}"; then
		_rc=1; _status="Error: cannot create build directories.";
	elif [ -e "${DEFAULT_BUILD_STATUS_IN_PROGRESS_FNAME}" ]; then
		_rc=1; _status="Error: another build targeting this architecture and build type is currently in progress.";
	elif ! rtl_clean_env "${DEFAULT_CLEAR_ENV_VARS_EXCEPT}"; then
		_rc=1; _status="Error: failed to clean environment.";
	elif ! rtl_check_path_vars "${DEFAULT_CHECK_PATH_VARS}"; then
		_rc=1; _status="${_status}";
	else
		touch "${DEFAULT_BUILD_STATUS_IN_PROGRESS_FNAME}";
		if [ -e "${DEFAULT_BUILD_LOG_FNAME}" ]; then
			_log_last_ts="$(stat -c %Y "${DEFAULT_BUILD_LOG_FNAME}")";
			_log_last_ts="$(awk 'BEGIN {printf(strftime("%Y-%m-%d-%H-%M-%S", '"${_log_last_ts}"'))}')";
			_log_last_fname="${DEFAULT_BUILD_LOG_FNAME}.${_log_last_ts}";
			rtl_fileop mv "${DEFAULT_BUILD_LOG_FNAME}" "${_log_last_fname}";
			rtl_fileop ln_symbolic "${_log_last_fname}" "${DEFAULT_BUILD_LOG_LAST_FNAME}";
		fi;
		rtl_fileop touch "${DEFAULT_BUILD_LOG_FNAME}";
		if rtl_lmatch "${ARG_CLEAN_BUILDS}" "prefix" ","; then
			rtl_log_msg info "-C prefix specified, cleaning prefix...";
			for _pname in ${DEFAULT_CLEAR_PREFIX_PATHS}; do
				if ! rtl_fileop rm "${PREFIX}/${_pname}"; then
					_rc=1; _status="Error: failed to remove \`${PREFIX}/${_pname}'."; break;
				fi;
			done;
		fi;
		export PATH="${PREFIX}/bin${PATH:+:${PATH}}";
	fi;
	return "${_rc}";
};

buildp_init_getopts() {
	local _arg="" _opt="" _rc=0 _shiftfl=0 OPTIND=0; _status="";
	while [ "${#}" -gt 0 ]; do
		case "${1}" in
		--as-needed)	ARG_AS_NEEDED=1; _shiftfl=1; ;;
		--dump-in)	if [ "${#}" -ge 2 ]; then
					ARG_DUMP_IN="${2}"; ARG_DUMP_ON_ABORT=1; _shiftfl=2;
				else
					_rc=1; _status="Error: missing argument to option --dump-in.";
				fi; ;;
		--dump-on-abort)
				ARG_DUMP_ON_ABORT=1; _shiftfl=1; ;;
		--debug-minipx)	ARG_DEBUG_MINIPIX=1; _shiftfl=1; ;;
		-v*)		_opt="${1#-}"; while [ -n "${_opt}" ]; do
					: $((ARG_VERBOSE+=1)); _opt="${_opt#?}";
				done; _shiftfl=1; ;;
		*)		_shiftfl=0; ;;
		esac;
		if [ "${_rc}" -ne 0 ]; then
			break;
		elif [ "${_shiftfl}" -gt 0 ]; then
			shift "${_shiftfl}"; continue;
		elif getopts a:b:C:D:Fhp:Pr:R _opt; then
			case "${_opt}" in
			a)	ARCH="${OPTARG}"; ;;
			b)	BUILD="${OPTARG}"; ;;
			C)	ARG_CLEAN_BUILDS="${OPTARG}"; ;;
			D)	ARG_DIST="${OPTARG}"; ;;
			F)	ARG_FETCH_FORCE=1; ;;
			h)	cat etc/build.usage; exit 0; ;;
			p)	ARG_PARALLEL="${OPTARG}"; ;;
			P)	ARG_PARALLEL="auto"; ;;
			r)	ARG_RESTART="${OPTARG}"; ;;
			R)	ARG_RELAXED=1; ;;
			*)	cat etc/build.usage; exit 1; ;;
			esac; shift $((${OPTIND}-1)); OPTIND=1;
		else
			break;
		fi;
	done;
	if [ "${_rc}" -eq 0 ]; then
		if [ "${ARG_DUMP_ON_ABORT:-0}" -eq 1 ]\
		&& [ "${ARG_RELAXED:-0}" -eq 1 ]; then
			_rc=1; _status="Error: --dump-on-abort excludes -R.";
		else	while [ ${#} -gt 0 ]; do
			if [ "${1#\*}" != "${1}" ]; then
				BUILD_GROUPS_INHIBIT_DEPS=1; _arg="${1#\*}";
			else
				_arg="${1}";
			fi;
			case "${_arg}" in
			*=*)		rtl_set_var_unsafe "${_arg%%=*}" "${_arg#*=}"; ;;
			[^a-zA-Z]*)	_rc=1; _status="Error: build group names must start with [a-zA-Z] (in argument \`${_arg}'.)"; ;;
			*[^_a-zA-Z]*)	_rc=1; _status="Error: build group names must not contain [^_a-zA-Z] (in argument \`${_arg}'.)"; ;;
			*)		BUILD_GROUPS="$(rtl_lconcat "${BUILD_GROUPS}" "${_arg}")"; ;;
			esac; shift; done;
		fi;
	fi;
	return "${_rc}";
};

buildp_init_groups() {
	local _default_build_groups="" _fname="" _group="" _groups="" _rc=0; _status="";
	for _fname in $(find ./groups -name *.group | sort); do
		rtl_fileop source_opt "${_fname}";
		if [ -n "${GROUP_TARGET}" ]; then
			_group="${GROUP_TARGET}"; unset GROUP_TARGET;
		else
			_group="${_fname##*/}"; _group="${_group%.group}"; _group="${_group#*.}";
		fi;
		if ! rtl_lmatch "${_groups}" "${_group}"; then
			_groups="$(rtl_lconcat "${_groups}" "${_group}")";
			if [ -n "${GROUP_AUTO}" ]; then
				if [ "${GROUP_AUTO:-0}" -ne 0 ]; then
					_default_build_groups="$(rtl_lconcat "${_default_build_groups}" "${_group}")";
				fi;
				unset GROUP_AUTO;
			else
				_default_build_groups="$(rtl_lconcat "${_default_build_groups}" "${_group}")";
			fi;
		fi;
	done;
	_default_build_groups="$(rtl_uniq "${_default_build_groups}")";
	if ! rtl_lmatch "${ARG_DIST}" "rpm" ","; then
		_default_build_groups="$(rtl_lfilter "${_default_build_groups}" "host_deps_rpm")";
	fi;
	if [ -z "${BUILD_GROUPS}" ]; then
		BUILD_GROUPS="${_default_build_groups}";
	fi;
	if [ -n "${ARG_DIST}" ]; then
		BUILD_GROUPS="$(rtl_lconcat "$(rtl_lfilter "${BUILD_GROUPS}" "dist")" "dist")";
	fi;
	for _group in ${BUILD_GROUPS}; do
		if ! rtl_lmatch "${_groups}" "${_group}"; then
			_rc=1; _status="Error: unknown build group \`${_group}'."; break;
		fi;
	done;
	return "${_rc}";
};

buildp_init_prereqs() {
	local _cmd="" _cmds_missing="" _rc=0; _status="";
	for _cmd in	\
			awk bunzip2 cat chmod cmake cp date find flock g++	\
			gcc git grep gunzip gzip hostname install kill		\
			ln lzip make mkdir mkfifo mv paste patch perl		\
			pgrep pkill printf readlink rm sed seq sha256sum	\
			sort stat tail tar test touch tr wget xz zip; do
		if ! which "${_cmd}" >/dev/null 2>&1; then
			_cmds_missing="${_cmds_missing:+${_cmds_missing} }${_cmd}";
		fi;
	done;
	if [ -n "${_cmds_missing}" ]; then
		_rc=1; _status="Error: missing prerequisite package(s): ${_cmds_missing}";
	elif ! awk -V 2>/dev/null | grep -q "^GNU Awk "; then
		_rc=1; _status="Error: awk(1) in \$PATH must be GNU Awk.";
	elif ! sed --version 2>/dev/null | grep -q "^GNU sed "; then
		_rc=1; _status="Error: sed(1) in \$PATH must be GNU sed.";
	fi;
	return "${_rc}";
};

buildp_init_vars() {
	local _rc=0; _status="";
	if ! rtl_lmatch "${ARCH}" "nt32 nt64"; then
		_rc=1; _status="Error: invalid architecture \`${ARCH}'.";
	elif ! rtl_lmatch "${BUILD}" "debug release"; then
		_rc=1; _status="Error: unknown build type \`${BUILD}'.";
	elif [ -n "${ARG_PARALLEL}" ] &&  [ "${ARG_PARALLEL}" != "auto" ]\
	&&   ! rtl_isnumber "${ARG_PARALLEL}"; then
		_rc=1; _status="Error: invalid jobs count \`${ARG_PARALLEL}'.";
	else	case "${ARCH}" in
		nt32)	DEFAULT_TARGET="i686-nt32-midipix"; ;;
		nt64)	DEFAULT_TARGET="x86_64-nt64-midipix"; ;;
		esac;
		if [ -e "/proc/cpuinfo" ]; then
			DEFAULT_BUILD_CPUS="$(awk '/^processor/{cpus++} END{print cpus}' /proc/cpuinfo)";
			if [ "${ARG_PARALLEL}" = "auto" ]\
			&& [ "${DEFAULT_BUILD_CPUS}" -gt 1 ]; then
				ARG_PARALLEL=$((${DEFAULT_BUILD_CPUS}/2));
			fi;
		fi;
		rtl_fileop source_opt							\
			"${HOME}/midipix_build.vars" "${HOME}/.midipix_build.vars"	\
			../midipix_build.vars ./midipix.env;
		if [ -z "${PREFIX}" ]; then
			_rc=1; _status="Error: \${PREFIX} empty or unset.";
		fi; fi;
	return "${_rc}";
};

build_init() {
	local _fname="" _rc=0 _status="";
	if ! buildp_init_env		\
	|| ! buildp_init_defaults	\
	|| ! buildp_init_getopts "${@}"	\
	|| ! buildp_init_prereqs	\
	|| ! buildp_init_vars		\
	|| ! buildp_init_groups		\
	|| ! buildp_init_args		\
	|| ! buildp_init_files; then
		_rc="${?}"; rtl_log_msg fail "${_status}"; exit "${_rc}";
	elif [ -n "${_status}" ]; then
		rtl_log_msg info "${_status}"; exit 0;
	else
		return "${_rc}";
	fi;
};

# vim:filetype=sh
